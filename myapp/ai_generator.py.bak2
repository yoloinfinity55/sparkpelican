"""
AI Blog Post Generation Module - IMPROVED VERSION

Enhanced with:
1. Better title generation (SEO-optimized, no quotes, multiple formats)
2. More concise content generation (40-60% compression)
3. Structured blog formatting
4. Better prompt engineering
"""

import asyncio
import os
from datetime import datetime
from typing import Dict, Optional, List
import logging
import re

try:
    import google.generativeai as genai
    GEMINI_AVAILABLE = True
except ImportError:
    GEMINI_AVAILABLE = False
    genai = None

from slugify import slugify

logger = logging.getLogger(__name__)

class AIGenerationError(Exception):
    """Custom exception for AI generation errors."""
    pass

class AIGenerator:
    """AI-powered blog post generator using Google Gemini - IMPROVED."""

    def __init__(self):
        """Initialize the AI generator with Gemini configuration."""
        if not GEMINI_AVAILABLE:
            raise AIGenerationError("google-generativeai not installed")

        api_key = os.getenv('GEMINI_API_KEY')
        if not api_key:
            raise AIGenerationError("GEMINI_API_KEY environment variable not set")

        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-1.5-flash')

        # Optimized generation parameters
        self.generation_config = genai.types.GenerationConfig(
            temperature=0.7,
            top_p=0.8,
            top_k=40,
            max_output_tokens=4096,
        )

    async def generate_post_async(
        self,
        transcript: str,
        video_id: str,
        custom_title: Optional[str] = None,
        category: str = "General",
        tags: List[str] = None
    ) -> Dict[str, str]:
        """Generate a complete blog post from YouTube transcript."""
        try:
            # Generate different parts concurrently
            title_task = self._generate_title_improved(transcript, custom_title)
            content_task = self._generate_content_improved(transcript, video_id)
            summary_task = self._generate_summary_improved(transcript)
            tags_task = self._generate_tags_improved(transcript, tags or [])

            title, content, summary, generated_tags = await asyncio.gather(
                title_task, content_task, summary_task, tags_task
            )

            # Create post slug
            post_slug = slugify(title)

            # Generate front matter (without quotes around title)
            front_matter = self._create_front_matter(
                title=title,
                date=datetime.now().isoformat(),
                author="AI Generated",
                category=category,
                tags=generated_tags,
                slug=post_slug,
                youtube_id=video_id,
                summary=summary
            )

            # Combine into full markdown
            full_content = f"---\n{front_matter}---\n\n{summary}\n\n{content}"

            return {
                "title": title,
                "slug": post_slug,
                "content": full_content,
                "front_matter": front_matter,
                "youtube_id": video_id,
                "category": category,
                "tags": generated_tags,
                "summary": summary
            }

        except Exception as e:
            logger.error(f"AI generation failed: {str(e)}")
            raise AIGenerationError(f"Failed to generate post: {str(e)}")

    async def _generate_title_improved(self, transcript: str, custom_title: Optional[str]) -> str:
        """
        IMPROVED: Generate better, SEO-optimized titles.
        
        Improvements:
        - Multiple title format options
        - Power words included
        - 50-60 character optimization
        - Removes video-specific language
        - No quotes in output
        """
        if custom_title:
            return self._clean_title(custom_title)

        # Extract key topics first for better context
        key_topics = await self._extract_key_topics(transcript[:2000])

        prompt = f"""Generate a compelling blog post title based on this video transcript.

REQUIREMENTS:
- Length: 50-60 characters (strict limit)
- Format: Choose the most appropriate format:
  * "How to [Action] [Benefit]"
  * "[Number] Ways to [Achieve Result]"
  * "Complete Guide to [Topic]"
  * "Why [Topic] Matters for [Audience]"
  * "[Action]: A [Adjective] Guide"
- Include power words: Complete, Essential, Proven, Ultimate, Simple, Effective
- Focus on value proposition and benefits
- Remove video-specific words: "Watch", "Episode", "Part", "#"
- Must be clear, specific, and actionable
- Do NOT use quotes around the title

Key Topics Identified: {key_topics}

Transcript excerpt:
{transcript[:1500]}

Generate 3 title options, then select the best one:

Title 1:
Title 2:
Title 3:

BEST TITLE (without quotes):"""

        try:
            response = await asyncio.get_event_loop().run_in_executor(
                None, self._call_gemini, prompt
            )
            
            # Extract the best title from response
            title = self._extract_best_title(response)
            title = self._clean_title(title)
            title = self._optimize_title_length(title)
            
            logger.info(f"Generated title: {title} ({len(title)} chars)")
            return title
            
        except Exception as e:
            logger.warning(f"Title generation failed, using fallback: {str(e)}")
            return self._generate_fallback_title(transcript, key_topics)

    async def _extract_key_topics(self, transcript_excerpt: str) -> str:
        """Extract 2-3 main topics from transcript for better title generation."""
        prompt = f"""Extract the 2-3 main topics from this transcript in 5 words or less.

Transcript:
{transcript_excerpt}

Main topics (comma-separated, 5 words max):"""

        try:
            response = await asyncio.get_event_loop().run_in_executor(
                None, self._call_gemini, prompt
            )
            return response.strip()[:100]  # Limit length
        except:
            # Fallback: extract first meaningful nouns
            words = transcript_excerpt.split()[:50]
            return ' '.join(words[:10])

    def _clean_title(self, title: str) -> str:
        """Remove quotes, extra spaces, and video-specific language."""
        # Remove quotes
        title = title.strip().strip('"').strip("'").strip('`')
        
        # Remove video-specific terms
        video_terms = ['watch this', 'in this video', 'episode', 'part', '#', '|']
        for term in video_terms:
            title = re.sub(term, '', title, flags=re.IGNORECASE)
        
        # Clean up extra spaces
        title = ' '.join(title.split())
        
        # Capitalize properly
        title = self._title_case(title)
        
        return title

    def _title_case(self, title: str) -> str:
        """Apply proper title case."""
        small_words = {'a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'in', 'of', 'on', 'or', 'the', 'to', 'with'}
        words = title.split()
        
        if not words:
            return title
        
        # Always capitalize first and last word
        words[0] = words[0].capitalize()
        if len(words) > 1:
            words[-1] = words[-1].capitalize()
        
        # Handle middle words
        for i in range(1, len(words) - 1):
            if words[i].lower() not in small_words:
                words[i] = words[i].capitalize()
            else:
                words[i] = words[i].lower()
        
        return ' '.join(words)

    def _optimize_title_length(self, title: str) -> str:
        """Ensure title is 50-60 characters for SEO."""
        if len(title) <= 60:
            return title
        
        # Try to cut at word boundary
        if len(title) > 60:
            title = title[:57]
            last_space = title.rfind(' ')
            if last_space > 40:  # Keep at least 40 chars
                title = title[:last_space]
            title += '...'
        
        return title

    def _extract_best_title(self, response: str) -> str:
        """Extract the best title from multi-option response."""
        lines = response.split('\n')
        
        # Look for "BEST TITLE" marker
        for i, line in enumerate(lines):
            if 'BEST TITLE' in line.upper() or 'best:' in line.lower():
                if i + 1 < len(lines):
                    return lines[i + 1].strip()
        
        # Otherwise, get last non-empty line (usually the selected title)
        for line in reversed(lines):
            line = line.strip()
            if line and not line.startswith(('Title', 'BEST', '---', '*')):
                return line
        
        # Fallback to first non-empty line
        for line in lines:
            line = line.strip()
            if line and len(line) > 10:
                return line
        
        return "Generated Blog Post"

    def _generate_fallback_title(self, transcript: str, key_topics: str) -> str:
        """Generate a fallback title when AI fails."""
        # Extract first meaningful sentence
        sentences = transcript.split('.')[:5]
        for sentence in sentences:
            sentence = sentence.strip()
            if len(sentence) > 20 and len(sentence) < 100:
                # Create title from sentence
                title = sentence[:60]
                if not title.endswith('.'):
                    title = self._optimize_title_length(title)
                return self._clean_title(title)
        
        # Ultimate fallback
        if key_topics:
            return f"Guide to {key_topics[:40]}"
        return "Essential Video Content Guide"

    async def _generate_content_improved(self, transcript: str, video_id: str) -> str:
        """
        IMPROVED: Generate concise, well-structured blog content.
        
        Improvements:
        - 40-60% compression of transcript
        - Clear structure with sections
        - Removes filler words and repetition
        - Professional blog style (not spoken style)
        - Includes key takeaways
        """
        
        # Calculate target length (50% of transcript)
        transcript_words = len(transcript.split())
        target_words = int(transcript_words * 0.5)
        
        prompt = f"""Transform this YouTube video transcript into a professional blog post.

CRITICAL REQUIREMENTS:
- Length: Approximately {target_words} words (50% of original)
- Remove ALL filler words: "um", "uh", "like", "you know", "basically", "actually"
- Remove repetitions and redundant explanations
- Focus ONLY on key insights and actionable information
- Write in clear, professional paragraphs (not spoken style)

STRUCTURE (must follow exactly):
## Introduction
[2-3 sentences: Hook reader + What they'll learn + Why it matters]

## Key Takeaways
[Bullet list: 3-5 main points - be specific and actionable]

## [Section 1 - Descriptive Heading]
[2-3 concise paragraphs covering first major topic]

## [Section 2 - Descriptive Heading]
[2-3 concise paragraphs covering second major topic]

## [Section 3 - Descriptive Heading]
[2-3 concise paragraphs covering third major topic]

## Practical Applications
[Bullet list: 3-4 specific action steps readers can take]

## Conclusion
[2-3 sentences: Summarize value + Call to action]

WRITING STYLE:
- Short paragraphs (2-4 sentences max)
- Active voice only
- Specific examples instead of vague statements
- One idea per paragraph
- Use subheadings for clarity
- Bold important terms sparingly

EXCLUDE:
- Any reference to "in this video", "the speaker says", timestamps
- Tangents and off-topic content
- Overly detailed explanations
- Marketing fluff

Transcript:
{transcript}

Blog Post (markdown format):"""

        try:
            response = await asyncio.get_event_loop().run_in_executor(
                None, self._call_gemini, prompt
            )
            
            # Post-process to ensure quality
            content = self._post_process_content(response)
            
            # Verify length target was met
            content_words = len(content.split())
            logger.info(f"Generated content: {content_words} words (target: {target_words}, ratio: {content_words/transcript_words:.1%})")
            
            return content
            
        except Exception as e:
            logger.error(f"Content generation failed: {str(e)}")
            return self._generate_fallback_content(transcript, video_id)

    def _post_process_content(self, content: str) -> str:
        """Clean up generated content."""
        # Remove common filler phrases
        filler_phrases = [
            r'\b(um|uh|like|you know|basically|actually)\b',
            r'\b(in this video|the speaker says|as mentioned)\b',
            r'\[.*?\]',  # Remove bracket annotations
        ]
        
        for pattern in filler_phrases:
            content = re.sub(pattern, '', content, flags=re.IGNORECASE)
        
        # Clean up extra whitespace
        content = re.sub(r'\n{3,}', '\n\n', content)
        content = re.sub(r' +', ' ', content)
        
        return content.strip()

    def _generate_fallback_content(self, transcript: str, video_id: str) -> str:
        """Generate fallback content when AI fails."""
        # Create basic structure from transcript
        words = transcript.split()
        content_length = min(len(words) // 2, 500)  # 50% but max 500 words
        
        content = f"""## Introduction

This content is based on a YouTube video exploring important concepts and insights.

## Key Points

{' '.join(words[:content_length])}

## Conclusion

For the complete discussion, watch the [original video](https://www.youtube.com/watch?v={video_id})."""
        
        return content

    async def _generate_summary_improved(self, transcript: str) -> str:
        """
        IMPROVED: Generate concise, engaging 2-3 sentence summary.
        """
        prompt = f"""Create a compelling 2-3 sentence summary that makes someone want to read this blog post.

REQUIREMENTS:
- Length: 2-3 sentences (150 words max)
- First sentence: Hook with the main benefit or insight
- Second sentence: Key takeaway or learning
- Third sentence (optional): Who should read this or call to action
- Write in active voice, be specific
- Do NOT start with "This post/article/video discusses..."

Transcript excerpt:
{transcript[:2000]}

Summary:"""

        try:
            response = await asyncio.get_event_loop().run_in_executor(
                None, self._call_gemini, prompt
            )
            summary = response.strip()
            
            # Validate summary quality
            if len(summary) > 20 and not any(word in summary.lower() for word in ['error', 'failed', 'unable']):
                return summary
        except Exception as e:
            logger.warning(f"Summary generation failed: {str(e)}")
        
        return self._generate_fallback_summary(transcript)

    def _generate_fallback_summary(self, transcript: str) -> str:
        """Generate fallback summary when AI fails."""
        try:
            sentences = [s.strip() for s in transcript.split('.') if len(s.strip()) > 30]
            
            # Find sentences that don't start with common filler
            meaningful = []
            for sentence in sentences[:15]:
                if not any(sentence.lower().startswith(word) for word in ['hey', 'hi', 'hello', 'so', 'okay', 'um', 'uh']):
                    meaningful.append(sentence)
                    if len(meaningful) >= 2:
                        break
            
            if meaningful:
                summary = '. '.join(meaningful[:2])
                if not summary.endswith('.'):
                    summary += '.'
                return summary
            
            # Ultimate fallback
            words = transcript.split()[:40]
            return f"{' '.join(words)}..."
            
        except:
            return "Discover valuable insights and practical knowledge from this comprehensive video content."

    async def _generate_tags_improved(self, transcript: str, custom_tags: List[str]) -> List[str]:
        """IMPROVED: Generate more relevant, specific tags."""
        if custom_tags:
            return [tag.lower().strip() for tag in custom_tags]

        prompt = f"""Generate 5-7 specific, relevant tags for this blog post.

REQUIREMENTS:
- Use lowercase, no spaces (use-hyphens-for-phrases)
- Be specific (not generic like "video" or "content")
- Include: topic keywords, technologies, concepts, target audience
- Avoid: overly broad terms, duplicates

Transcript:
{transcript[:1500]}

Tags (comma-separated):"""

        try:
            response = await asyncio.get_event_loop().run_in_executor(
                None, self._call_gemini, prompt
            )
            tags = [tag.strip().lower() for tag in response.split(',') if tag.strip()]
            return tags[:7]
        except:
            return ["tutorial", "guide", "learning"]

    def _call_gemini(self, prompt: str) -> str:
        """Synchronous Gemini API call."""
        try:
            response = self.model.generate_content(
                prompt,
                generation_config=self.generation_config
            )
            return response.text
        except Exception as e:
            logger.error(f"Gemini API call failed: {str(e)}")
            raise

    def _create_front_matter(
        self,
        title: str,
        date: str,
        author: str,
        category: str,
        tags: List[str],
        slug: str,
        youtube_id: str,
        summary: str
    ) -> str:
        """Create Pelican front matter YAML - WITHOUT QUOTES around title."""
        # Ensure title doesn't have quotes
        title = title.strip('"').strip("'")
        
        front_matter_lines = [
            f"title: {title}",  # No quotes!
            f"date: {date}",
            f"author: {author}",
            f"category: {category}",
            f"tags: {', '.join(tags)}",
            f"slug: {slug}",
            f"youtube_id: {youtube_id}",
            f"summary: {summary}"
        ]
        return '\n'.join(front_matter_lines)


# Global generator instance
_generator_instance = None

async def generate_post_async(**kwargs) -> Dict[str, str]:
    """Convenience function to generate a post."""
    global _generator_instance

    if _generator_instance is None:
        _generator_instance = AIGenerator()

    return await _generator_instance.generate_post_async(**kwargs)